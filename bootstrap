#!/usr/bin/env bash

function main() {
    parse_args $@
    set_platform_and_username

    [[ $zsh_flag      = true ]] && configure_zsh
    [[ $vim_flag      = true ]] && configure_vim
    [[ $dotfiles_flag = true ]] && configure_dotfiles

    printf '\n\n ~~~ finished configuring shell, you might need to restart ~~~ \n\n'
}

dotfiles=(
    'gemrc'
    'gitconfig'
    'gitignore_global'
    'pryrc'
    'rspec'
    'ruby-version'
    'tmux.conf'
)

platform='unknown'

bundler_flag=false # TODO
zsh_flag=false
vim_flag=false
dotfiles_flag=false

function parse_args() {
    for opt in "$@"
    do
        case "$opt" in
            --verbose)
                verbose_output=true
                ;;

            --dry-run)
                dry_run=true
                ;;

            --zsh)
                zsh_flag=true
                ;;

            --vim)
                vim_flag=true
                ;;

            --bundler)
                bundler_flag=false # TODO
                ;;

            --dotfiles)
                dotfiles_flag=true
                ;;

            *)
                printf "unknown argument:\t$(red $opt)\n\n"
                printf "usage:\n\t--verbose\t\t\tdebugging output\n"
                printf "\t--dry-run\t\t\tdon't actually make changes\n"
                printf "\t--zsh\t\t\t\tconfigure zsh\n"
                printf "\t--vim\t\t\t\tconfigure vim\n"
                printf "\t--dotfiles\t\t\tconfigure dotfiles\n"
                exit 1
                ;;
        esac
    done
}

function set_platform_and_username() {
    case "$(uname)" in
        "Darwin")
            platform="osx"
            username="ben"
            groupname="staff"
            home_dir="/Users/$username"
            ;;

        "Linux")
            platform="ubuntu"
            username="vagrant"
            groupname="vagrant"
            # in vagrant provisioners, $HOME is /root
            home_dir="/home/$username"
            ;;

        *)
            printf "unknown platform:\t$(red $uname)\n\n"
            exit 1
            ;;
    esac

    env_dir="$home_dir/dev-env"
    bundler_dir="$home_dir/.bundle"
    zsh_dir="$home_dir/.zsh"
    vim_dir="$home_dir/.vim"

    chown -R $username:$groupname $env_dir
}

function configure_zsh() {
    if wet_flagged; then
        if [[ -e "$zsh_dir" ]]; then
            echo "configure_zsh failed: $(red $zsh_dir) already exists"
            exit 1
        fi

        if on_ubuntu_vm; then
            apt-get update
            apt-get install zsh tree silversearcher-ag -y
            # Homebrew stuff on OSX might just have to be done manually
        fi

        nonroot_symlink $env_dir/zsh $zsh_dir

        nonroot_symlink $zsh_dir/zshrc $home_dir/.zshrc
        nonroot_symlink $zsh_dir/zshenv $home_dir/.zshenv

        chsh -s $(which zsh) $username
    fi

    if verbose_flagged; then
        if on_ubuntu_vm; then
            echo 'installed: zsh, tree, ag'
        fi

        echo 'ran zsh bootstrap script'
    fi
}

function nonroot_symlink() {
    local target_path=$1
    local link_path=$2

    ln -s $target_path $link_path
    chown -R $username:$groupname $link_path
}

function configure_vim() {
    # both osx and ubuntu have a pretty new version in /usr/bin so I don't need to install it, just
    # run the setup script
    if wet_flagged; then
        if [[ -e "$vim_dir" ]]; then
            echo "configure_vim failed: $(red $vim_dir) already exists"
            exit 1
        fi

        nonroot_symlink $env_dir/vim $vim_dir
        nonroot_symlink $vim_dir/vimrc $home_dir/.vimrc
    fi

    if verbose_flagged; then
        echo 'linked vimrc'
    fi
}

function configure_dotfiles() {
    for dotfile in "${dotfiles[@]}"
    do
        local dotfile_path="${home_dir}/.${dotfile}"
        local dev_env_dotfile_path="${env_dir}/dotfiles/${dotfile}"

        if wet_flagged; then
            backup_and_rm $dotfile $dotfile_path
            link_dotfile $dev_env_dotfile_path $dotfile_path
        fi
    done
}

function backup_and_rm() {
    local dotfile=$1
    local dotfile_path=$2
    local timestamp=$(date +"%Y%m%d%H%M%S")

    local backup_file="${env_dir}/backups/${dotfile}_${timestamp}"

    if [[ -e $dotfile_path ]]; then
        cat $dotfile_path > $backup_file
        chown -R $username:$groupname $backup_file

        if verbose_flagged; then
            echo "created backup file $(green $backup_file)"
        fi
    else
        if verbose_flagged; then
            echo "no existing dotfile: $(yellow $dotfile_path)"
        fi
    fi

    if [[ -e $backup_file ]]; then
        rm $dotfile_path

        if verbose_flagged; then
            echo "removed old dotfile: $(red $dotfile_path)"
        fi
    fi
}

function link_dotfile() {
    local dev_env_dotfile_path=$1
    local dotfile_path=$2

    ln -s $dev_env_dotfile_path $dotfile_path
    chown -R $username:$groupname $dotfile_path

    if verbose_flagged; then
        echo "linked $(green $dotfile_path) to $(green $dev_env_dotfile_path)"
    fi
}

## helper functions

red_id=1; green_id=2; yellow_id=3; blue_id=4; magenta_id=5; cyan_id=6; white_id=7; black_id=8
function change_color() { echo "$(tput setaf $1)$2$(tput sgr0)"; }
function red() { echo "$(change_color $red_id $1)"; }
function yellow() { echo "$(change_color $yellow_id $1)"; }
function green() { echo "$(change_color $green_id $1)"; }

function on_ubuntu_vm() { [[ $platform == 'ubuntu' ]]; }
function verbose_flagged() { [[ "$verbose_output" = true ]]; }
function wet_flagged() { [[ "$dry_run" != true ]]; }

main $@
