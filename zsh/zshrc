### Completion ###
setopt COMPLETE_IN_WORD
autoload -U compinit
compinit
zstyle ':completion::complete:*' use-cache 1
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}' # case insensitive completion


### Colors ###
export CLICOLOR=1
autoload colors
colors


### History ###
export HISTFILE=$HOME/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000
setopt EXTENDED_HISTORY     # add timestamps to history
setopt APPEND_HISTORY       # adds history
setopt INC_APPEND_HISTORY   # adds history incrementally
setopt SHARE_HISTORY        # share across sessions
setopt HIST_IGNORE_ALL_DUPS # don't record dupes in history
setopt HIST_IGNORE_DUPS
setopt HIST_REDUCE_BLANKS


### Settings ###
unsetopt correct_all
bindkey -e                                       # use emacs key bindings
bindkey '^r' history-incremental-search-backward # make Control-r work
bindkey '^[[Z' reverse-menu-complete             # shift-tab to cycle backwards
bindkey "^[[3~" delete-char                      # make delete key work
bindkey "^[3;5~" delete-char                     # make delete key work
bindkey "^U" backward-kill-line                  # C-u acts like bash
autoload -U select-word-style
select-word-style bash

setopt LOCAL_OPTIONS # allow functions to have local options
setopt LOCAL_TRAPS   # allow functions to have local traps
setopt PROMPT_SUBST
setopt AUTO_CD
setopt RC_QUOTES     # 'allow ''single'' quote interpolation'
stty -ixon -ixoff    # disable scroll lock
export EDITOR=vim
set -o emacs

function try_source() {
    [ -f "$1" ] && source "$1"
}

try_source $HOME/.zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
try_source $HOME/.zsh/
try_source /usr/local/share/chruby/chruby.sh
try_source /usr/local/share/chruby/auto.sh


### Prompt ###
function in_git_repo() { git rev-parse 2> /dev/null }

function current_dir()    { echo "[%{$fg_bold[blue]%}%~%{$reset_color%}]" }
function current_branch() {
    if in_git_repo; then
        local branch_name=$(git rev-parse --symbolic-full-name --abbrev-ref HEAD)
        echo "[%{$fg_bold[cyan]%}$branch_name%{$reset_color%}]"
    else
        echo ""
    fi
}

export PS1='$(current_branch)$(current_dir) '


### Aliases ###
alias ls='ls --color'
alias grep='grep --color=auto'
alias sudo='sudo ' # make aliases work with "sudo"
alias tmux='tmux -2' # let tmux use 256 colors

alias l='ls -lhpG'
alias emacs='emacs-snapshot '
alias e='emacs'
alias t='tree -C --dirsfirst -I "coverage|build|dist|*srv" '
alias t2='t -L 2'
alias be='bundle exec'

### Functions ###
function show-path() { echo $PATH | tr ':' '\n' }

function git-ssh() {
    touch ~/.ssh/config
    echo "Host github.com\n  StrictHostKeyChecking no" >> ~/.ssh/config
} 

function dull_red()     { echo "$(tput setaf 1)$1$(tput sgr0)" }
function dull_green()   { echo "$(tput setaf 2)$1$(tput sgr0)" }
function dull_yellow()  { echo "$(tput setaf 3)$1$(tput sgr0)" }
function dull_blue()    { echo "$(tput setaf 4)$1$(tput sgr0)" }
function dull_magenta() { echo "$(tput setaf 5)$1$(tput sgr0)" }
function dull_cyan()    { echo "$(tput setaf 6)$1$(tput sgr0)" }
function dull_white()   { echo "$(tput setaf 7)$1$(tput sgr0)" }
function dull_black()   { echo "$(tput setaf 8)$1$(tput sgr0)" }
function hot_red()      { echo "$(tput setaf 9)$1$(tput sgr0)" }
function hot_green()    { echo "$(tput setaf 10)$1$(tput sgr0)" }
function hot_yellow()   { echo "$(tput setaf 11)$1$(tput sgr0)" }
function hot_blue()     { echo "$(tput setaf 12)$1$(tput sgr0)" }
function hot_magenta()  { echo "$(tput setaf 13)$1$(tput sgr0)" }
function hot_cyan()     { echo "$(tput setaf 14)$1$(tput sgr0)" }
function hot_white()    { echo "$(tput setaf 15)$1$(tput sgr0)" }
function hot_black()    { echo "$(tput setaf 16)$1$(tput sgr0)" }

# for debugging
function show-color-functions() {
    echo "dull_red:     \t $(dull_red     'jump in the urinal')"
    echo "dull_green:   \t $(dull_green   'and stand on your head')"
    echo "dull_yellow:  \t $(dull_yellow  'im the one thats alive')"
    echo "dull_blue:    \t $(dull_blue    'youre all dead')"
    echo "dull_magenta: \t $(dull_magenta 'lean over the bowl')"
    echo "dull_cyan:    \t $(dull_cyan    'and then take a dive')"
    echo "dull_white:   \t $(dull_white   'all of you are dead')"
    echo "dull_black:   \t $(dull_black   'i am alive')\n"
    echo "hot_red:      \t $(hot_red      'jump in the urinal')"
    echo "hot_green:    \t $(hot_green    'and stand on your head')"
    echo "hot_yellow:   \t $(hot_yellow   'im the one thats alive')"
    echo "hot_blue:     \t $(hot_blue     'youre all dead')"
    echo "hot_magenta:  \t $(hot_magenta  'lean over the bowl')"
    echo "hot_cyan:     \t $(hot_cyan     'and then take a dive')"
    echo "hot_white:    \t $(hot_white    'all of you are dead')"
    echo "hot_black:    \t $(hot_black    'i am alive')\n"
}

#   Originally from https://github.com/mbadolato/iTerm2-Color-Schemes
function show-terminal-colors() {
    T='gYw'   # The test text

    echo -e "\n                 40m     41m     42m     43m\
     44m     45m     46m     47m";

    for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' \
                       '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' \
                       '  36m' '1;36m' '  37m' '1;37m';
    do FG=${FGs// /}
       echo -en " $FGs \033[$FG  $T  "
       for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
       do echo -en "$EINS \033[$FG\033[$BG  $T  \033[0m";
       done
       echo;
    done
    echo
}

function sha() {
    local commit

    if [ -z $1 ]; then
        commit=HEAD
    else
        commit=$1
    fi;

    local gitsha=$(git rev-list -1 $commit)

    echo -n $gitsha | pbcopy
    echo "pbcopied $gitsha"
}

function shrug() {
    echo -n "¯\_(ツ)_/¯" | pbcopy
}

function fig() {
    # find . | grep
    find . -not -path "./.git/*" | grep "$@"
}

function ir() {
    # interactive rebase
    git rebase -i HEAD~$1
}

function wip() {
    if [[ $@ == "" ]]; then
        local msg=$(date +'%H:%M:%S')
    else
        local msg="$(echo $(date +'%H:%M:%S') '==>' $@)"
    fi

    git add -A
    git commit -m $msg
}

function d() {
    if [[ -z "$1" ]]; then
        pushd $HOME 2>&1 > /dev/null
    else
        pushd "$1" 2>&1 > /dev/null
    fi
}

function du() {
    popd 2>&1 > /dev/null
}

function ds() {
    dirs | tr ' ' '\n'
}

function pss() {
    local process_names=$(echo $@ | sed 's/ /\\|/g')
    ps aux | grep -v grep | grep "$process_names"
}
